//
//  main.c
//  Modular
//
//  Created by Leandro Morgado on 4/6/14.
//  Pontifícia Universidade Católica do Rio de Janeiro 2014. All rights reserved.
//



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "matriz.h"
#include "lista.h"



                           
struct tpMatriz {         
    int m;                // NUMERO DE LINHAS
    int n;               //  NUMERO DE COLUNAS
    TpLista** mat;     //   TpLista* mat[n]
   
};


// FUNCAO PARA CRIAR MATRIZ M x N
MAT_tpCondRet MAT_CriarMatriz( TpMatriz* matriz, int linhas, int colunas )
{
    int i, j; // elemento A(ij)
   
    TpLista** vector; // TpLista* vector[colunas]
   
    LST_tpCondRet verifica; // verifica condicao de retorno de funcoes da lista.h
   
   
   
    matriz = (TpMatriz*)malloc(sizeof(TpMatriz)); // MATRIZ QUE A FUNCAO CRIA E DEVOLVE - OK!
   
    if( matriz == NULL)
        return MAT_CondRetFaltouMemoria;
   
    vector = (TpLista**)malloc(sizeof(TpLista*)*colunas); // VETOR DE PONTEIROS ALOCADO - OK!
   
    if( vector == NULL)
        return MAT_CondRetFaltouMemoria;
   
    // A PARTIR DAQUI MONTAMOS A ESTRUTURA MATRIZ:

    for( j = 0; j < colunas; j++) // 1ª) CAMINH0 NO VETOR NO SENTIDO ESQUERDA -> DIREITA
       
        if( LST_CriarLista( vector[j] ) == LST_CondRetOK) {    // 2º) ENTREGO A CABECA DA LISTA
           
            for( i = 0; i < linhas; i++) { // CAMINHO NAS LISTAS/COLUNAS DE CIMA PARA BAIXO
           
                verifica = LST_InserirNovoNoFim( vector[j] , NULL );
               
                if( verifica != LST_CondRetOK)
                    return MAT_CondRetFalhou;
            }
        }
       
        else
            return MAT_CondRetFalhou;
                   
                   
    // A PARTIR DAQUI MONTO A MATRIZ PROPRIAMENTE
   
    matriz -> m = linhas;
    matriz -> n = colunas;
    matriz -> mat = vector;
   

    return MAT_CondRetOK;
   
}
